
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>How to add a new Lidar driver &#8212; Sphinx documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx13.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/tabs.js"></script>
    <script src="../../_static/translations.js"></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="canonical" href="https://www.sphinx-doc.org/en/master/docs/howto/how_to_add_a_new_lidar_driver.html" />
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Sphinx documentation 中搜索"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.svg"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="fr" href="how_to_add_a_new_lidar_driver_cn.html" />
    <link rel="prev" title="如何添加新的lidar检测算法" href="how_to_add_a_new_lidar_detector_algorithm_cn.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script>
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../../README.html">Home</a></li>
    <li><a href="../quickstart/README.html">Get it</a></li>
    <li><a href="../../contents.html">Docs</a></li>
    <li><a href="../../development/index.html">Extend</a></li>
  </ul>
  <div>
    <a href="../../README.html">
      <img src="../../_static/sphinx.png" alt="Apollo Doc" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="how_to_add_a_new_lidar_driver_cn.html" title="fr"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="how_to_add_a_new_lidar_detector_algorithm_cn.html" title="如何添加新的lidar检测算法"
             accesskey="P">上一页</a> |</li>
        <li><a href="../../index.html">Apollo home</a>&#160;|</li>
        <li><a href="../../contents.html">Documentation</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">How to add a new Lidar driver</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">How to add a new Lidar driver</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#whats-inside-a-lidar-driver">What’s inside a lidar driver</a></li>
<li><a class="reference internal" href="#steps-to-add-a-new-lidar-driver">Steps to add a new Lidar driver</a><ul>
<li><a class="reference internal" href="#get-familiar-with-apollo-cyber-rt-framework">1. Get familiar with Apollo Cyber RT framework.</a></li>
<li><a class="reference internal" href="#define-message-for-raw-data">2. Define message for raw data</a></li>
<li><a class="reference internal" href="#access-the-raw-data">3. Access the raw data</a></li>
<li><a class="reference internal" href="#parse-the-scan-data-convert-to-pointcloud">4. Parse the scan data, convert to pointcloud</a></li>
<li><a class="reference internal" href="#motion-compensation-for-pointcloud">5. Motion compensation for pointcloud</a></li>
<li><a class="reference internal" href="#configure-the-dag-file">6. Configure the dag file</a></li>
<li><a class="reference internal" href="#run-the-lidar-driver-and-visualize-the-pointlcoud-output">7. Run the lidar driver and visualize the pointlcoud output</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="how_to_add_a_new_lidar_detector_algorithm_cn.html"
                        title="上一章">如何添加新的lidar检测算法</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="how_to_add_a_new_lidar_driver_cn.html"
                        title="下一章">fr</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/docs/howto/how_to_add_a_new_lidar_driver.md.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section class="tex2jax_ignore mathjax_ignore" id="how-to-add-a-new-lidar-driver">
<h1>How to add a new Lidar driver<a class="headerlink" href="#how-to-add-a-new-lidar-driver" title="永久链接至标题">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p>Lidar is a commonly used environment-aware sensor. Lidar uses pulsed laser to illuminate a target, receives the reflected pulse from the target, then calculates the distance to the target based on the time of laser return. Differences in multiple measurements can then be used to make digital 3-D representations of the environment.</p>
<p>As default, Apollo platform support multiple types of Lidar drivers, including 16 channels, 32 channels, 64 channels and 128 channels Velodyne lidars. This manual describes the major functions of Lidar driver and how to add a new lidar driver in Apollo platform.</p>
</section>
<section id="whats-inside-a-lidar-driver">
<h2>What’s inside a lidar driver<a class="headerlink" href="#whats-inside-a-lidar-driver" title="永久链接至标题">¶</a></h2>
<p>Taking velodyne lidar driver as an example, there are three major components:</p>
<ol class="simple">
<li><p><span class="xref myst">Driver</span>: Driver receives UDP data packets from lidar sensor, and packages the data packets into a frame of scanning data in the format of VelodyneScan. VelodyneScan is defined in file below:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modules</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">lidar</span><span class="o">/</span><span class="n">velodyne</span><span class="o">/</span><span class="n">proto</span><span class="o">/</span><span class="n">velodyne</span><span class="o">.</span><span class="n">proto</span>
</pre></div>
</div>
<ol class="simple">
<li><p><span class="xref myst">Parser</span>: Parser takes one frame data in format of VelodyneScan as input, converts the cloud points in the frame from spherical coordinate system to Cartesian coordinates system, then sends out the point cloud as output. The pointcloud format is defined in file below:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modules</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">proto</span><span class="o">/</span><span class="n">pointcloud</span><span class="o">.</span><span class="n">proto</span>
</pre></div>
</div>
<ol class="simple">
<li><p><span class="xref myst">Compensator</span>: Compensator takes pointcloud data and pose data as inputs. Based on the corresponding pose information for each cloud point, it converts each cloud point information aligned with the latest time in the current lidar scan frame, minimizing the motion error due the movement of the vehicle. Thus, each cloud point needs carry its own timestamp information.</p></li>
</ol>
</section>
<section id="steps-to-add-a-new-lidar-driver">
<h2>Steps to add a new Lidar driver<a class="headerlink" href="#steps-to-add-a-new-lidar-driver" title="永久链接至标题">¶</a></h2>
<section id="get-familiar-with-apollo-cyber-rt-framework">
<h3>1. Get familiar with Apollo Cyber RT framework.<a class="headerlink" href="#get-familiar-with-apollo-cyber-rt-framework" title="永久链接至标题">¶</a></h3>
<p>Please refer to the <span class="xref myst">manuals of Apollo Cyber RT</span>.</p>
</section>
<section id="define-message-for-raw-data">
<h3>2. Define message for raw data<a class="headerlink" href="#define-message-for-raw-data" title="永久链接至标题">¶</a></h3>
<p>Apollo already define the format of pointcloud. For new lidar, you only need to define the protobuf message for the raw scannning data. Those raw data will be used for archive and offline development. Compared to processed pointcloud data, raw data saves a lot of storage spaces for long term. The new message of the scan data can be define as below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// a scan message sample</span>
<span class="n">message</span><span class="w"> </span><span class="n">ScanData</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">optional</span><span class="w"> </span><span class="n">apollo</span><span class="p">.</span><span class="n">common</span><span class="p">.</span><span class="n">Header</span><span class="w"> </span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// apollo header</span>
<span class="w">	</span><span class="n">optional</span><span class="w"> </span><span class="n">Model</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">                  </span><span class="c1">// device model</span>
<span class="w">	</span><span class="n">optional</span><span class="w"> </span><span class="n">Mode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">                    </span><span class="c1">// work mode</span>
<span class="w">	</span><span class="c1">// device serial number, corresponds to a specific calibration file</span>
<span class="w">	</span><span class="n">optional</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">sn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">repeated</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="n">raw_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">               </span><span class="c1">// raw scan data</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In velodyne driver, the scan data message is define as <a class="reference external" href="../../modules/drivers/lidar/velodyne/proto/velodyne.proto#L29">VelodyneScan</a>.</p>
</section>
<section id="access-the-raw-data">
<h3>3. Access the raw data<a class="headerlink" href="#access-the-raw-data" title="永久链接至标题">¶</a></h3>
<p>Each seconds, Lidar will generate a lot of data, so it relied on UDP to efficiently transport the raw data. You need to create a DriverComponent class, which inherits the Component withotu any parameter. In its Init function, you need to start a async polling thread, whic will receive Lidar data from the specific port. Then depending on the Lidar’s frequency, the DriverComponent needs to package all the packets in a fix period into a frame of ScanData. Eventually, the writer will send the ScanData through a corresponding channel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Inherit component with no template parameters,</span>
<span class="c1">// do not receive message from any channel</span>
<span class="k">class</span> <span class="nc">DriverComponent</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Component</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="o">~</span><span class="n">VelodyneDriverComponent</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Init</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  	</span><span class="n">poll_thread_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kr">thread</span><span class="p">([</span><span class="k">this</span><span class="p">]{</span><span class="w"></span>
<span class="w">  		</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Poll</span><span class="p">();</span><span class="w"></span>
<span class="w">  	</span><span class="p">}));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Poll</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">apollo</span><span class="o">::</span><span class="n">cyber</span><span class="o">::</span><span class="n">Ok</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  	  </span><span class="c1">// poll data from port xxx</span>
<span class="w">  	  </span><span class="c1">// ...</span>
<span class="w">  	  </span><span class="n">austo</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ScanData</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">  	  </span><span class="c1">// pack ScanData</span>
<span class="w">  	  </span><span class="c1">// ...</span>
<span class="w">  	  </span><span class="n">writer_</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">scan</span><span class="p">);</span><span class="w"></span>
<span class="w">  	</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span><span class="w"> </span><span class="n">poll_thread_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">apollo</span><span class="o">::</span><span class="n">cyber</span><span class="o">::</span><span class="n">Writer</span><span class="o">&lt;</span><span class="n">ScanData</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">writer_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">CYBER_REGISTER_COMPONENT</span><span class="p">(</span><span class="n">DriverComponent</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="parse-the-scan-data-convert-to-pointcloud">
<h3>4. Parse the scan data, convert to pointcloud<a class="headerlink" href="#parse-the-scan-data-convert-to-pointcloud" title="永久链接至标题">¶</a></h3>
<p>If the new lidar driver already provides the pointcloud data in Cartesian coordinates system, then you just need to store those data in the protobuf format defined in Apollo.</p>
<p>The Parser converts the lidar raw data to the pointcloud format in Cartesian coordinates system. Parser takes ScanData as input. For each cloud point, it will parse the timestamp, x/y/z coordinates and intensity, then packages all the cloudpoint information into a frame of pointcloud. Each cloud point transformed into the FLU (Front: x, Left: y, Up: z）coordinates with Lidar as the origin point.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">message</span><span class="w"> </span><span class="n">PointXYZIT</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nan</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nan</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nan</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Then you need to create a new ParserComponent，which inherits Components templates with ScanData. ParserComponent takes ScanData as input, then generates pointcloud message and sents it out.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="k">class</span> <span class="nc">ParserComponent</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Component</span><span class="o">&lt;</span><span class="n">ScanData</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">Init</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  	</span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">Proc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ScanData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">scan_msg</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// get a pointcloud object from objects pool</span>
<span class="w">  	</span><span class="k">auto</span><span class="w"> </span><span class="n">point_cloud_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_cloud_pool_</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="p">();</span><span class="w"></span>
<span class="w">  	</span><span class="c1">// clear befor using</span>
<span class="w">  	</span><span class="n">point_cloud_out</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  	</span><span class="c1">// parse scan data and generate pointcloud</span>
<span class="w">  	</span><span class="n">parser_</span><span class="o">-&gt;</span><span class="n">parse</span><span class="p">(</span><span class="n">scan_msg</span><span class="p">,</span><span class="w"> </span><span class="n">point_cloud_out</span><span class="p">);</span><span class="w"></span>
<span class="w">  	</span><span class="c1">// write pointcloud to a specific channel</span>
<span class="w">  	</span><span class="n">writer_</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">point_cloud</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&lt;</span><span class="n">PointCloud</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">writer_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Parser</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parser_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CCObjectPool</span><span class="o">&lt;</span><span class="n">PointCloud</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">point_cloud_pool_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pool_size_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">CYBER_REGISTER_COMPONENT</span><span class="p">(</span><span class="n">ParserComponent</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="motion-compensation-for-pointcloud">
<h3>5. Motion compensation for pointcloud<a class="headerlink" href="#motion-compensation-for-pointcloud" title="永久链接至标题">¶</a></h3>
<p>Motion compensation is optional depends on lidar hardware design. E.g. if the the pointcloud information from lidar already have the motion error included, then no compensator needed as extra steps. Otherwise, you need your own compensator. However, if each cloud point in your lidar’s output carries its own timestamp information, you can probably reuse the current compensator without any changes.</p>
</section>
<section id="configure-the-dag-file">
<h3>6. Configure the dag file<a class="headerlink" href="#configure-the-dag-file" title="永久链接至标题">¶</a></h3>
<p>After done with each component, you just need to configure the DAG config file to add each component into the data processing pipeline. E.g.  lidar_driver.dag:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define all coms in DAG streaming.</span>
<span class="n">module_config</span> <span class="p">{</span>
    <span class="n">module_library</span> <span class="p">:</span> <span class="s2">&quot;/apollo/bazel-bin/modules/drivers/lidar/xxx/driver/libxxx_driver_component.so&quot;</span>
    <span class="n">components</span> <span class="p">{</span>
      <span class="n">class_name</span> <span class="p">:</span> <span class="s2">&quot;DriverComponent&quot;</span>
      <span class="n">config</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">:</span> <span class="s2">&quot;xxx_driver&quot;</span>
        <span class="n">config_file_path</span> <span class="p">:</span> <span class="s2">&quot;/path/to/lidar_driver_conf.pb.txt&quot;</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">module_config</span> <span class="p">{</span>
    <span class="n">module_library</span> <span class="p">:</span> <span class="s2">&quot;/apollo/bazel-bin/modules/drivers/lidar/xxx/parser/libxxx_parser_component.so&quot;</span>
    <span class="n">components</span> <span class="p">{</span>
      <span class="n">class_name</span> <span class="p">:</span> <span class="s2">&quot;ParserComponent&quot;</span>
      <span class="n">config</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">:</span> <span class="s2">&quot;xxx_parser&quot;</span>
        <span class="n">config_file_path</span> <span class="p">:</span> <span class="s2">&quot;/path/to/lidar_parser_conf.pb.txt&quot;</span>
        <span class="n">readers</span> <span class="p">{</span> <span class="n">channel</span><span class="p">:</span> <span class="s2">&quot;/apollo/sensor/xxx/Scan&quot;</span> <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">module_config</span> <span class="p">{</span>
    <span class="n">module_library</span> <span class="p">:</span> <span class="s2">&quot;/apollo/bazel-bin/modules/drivers/lidar/xxx/compensator/libxxx_compensator_component.so&quot;</span>
    <span class="n">components</span> <span class="p">{</span>
      <span class="n">class_name</span> <span class="p">:</span> <span class="s2">&quot;CompensatorComponent&quot;</span>
      <span class="n">config</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">:</span> <span class="s2">&quot;pointcloud_compensator&quot;</span>
        <span class="n">config_file_path</span> <span class="p">:</span> <span class="s2">&quot;/apollo/modules/drivers/lidar/xxx/conf/xxx_compensator_conf.pb.txt&quot;</span>
        <span class="n">readers</span> <span class="p">{</span><span class="n">channel</span><span class="p">:</span> <span class="s2">&quot;/apollo/sensor/xxx/PointCloud2&quot;</span><span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="run-the-lidar-driver-and-visualize-the-pointlcoud-output">
<h3>7. Run the lidar driver and visualize the pointlcoud output<a class="headerlink" href="#run-the-lidar-driver-and-visualize-the-pointlcoud-output" title="永久链接至标题">¶</a></h3>
<p>After finishing all the previous steps, you can use the following command to start your new lidar driver.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mainboard -d /path/to/lidar_driver.dag
</pre></div>
</div>
<p>To visualize the pointcloud output, you can run <code class="docutils literal notranslate"><span class="pre">cyber_visualizer</span></code> and choose the right channel for the pointcloud.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="how_to_add_a_new_lidar_driver_cn.html" title="fr"
             >下一页</a> |</li>
        <li class="right" >
          <a href="how_to_add_a_new_lidar_detector_algorithm_cn.html" title="如何添加新的lidar检测算法"
             >上一页</a> |</li>
        <li><a href="../../index.html">Apollo home</a>&#160;|</li>
        <li><a href="../../contents.html">Documentation</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">How to add a new Lidar driver</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2021, xinetzone.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>