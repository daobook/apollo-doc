
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>HOW TO UNDERSTAND ARCHITECTURE AND WORKFLOW &#8212; Sphinx documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx13.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/tabs.js"></script>
    <script src="../../_static/translations.js"></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="canonical" href="https://www.sphinx-doc.org/en/master/docs/howto/how_to_understand_architecture_and_workflow.html" />
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Sphinx documentation 中搜索"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.svg"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="How to Update Vehicle Calibration for Throttle and Brakes" href="how_to_update_vehicle_calibration.html" />
    <link rel="prev" title="如何调节控制参数" href="how_to_tune_control_parameters_cn.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script>
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../../README.html">Home</a></li>
    <li><a href="../quickstart/README.html">Get it</a></li>
    <li><a href="../../contents.html">Docs</a></li>
    <li><a href="../../development/index.html">Extend</a></li>
  </ul>
  <div>
    <a href="../../README.html">
      <img src="../../_static/sphinx.png" alt="Apollo Doc" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="how_to_update_vehicle_calibration.html" title="How to Update Vehicle Calibration for Throttle and Brakes"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="how_to_tune_control_parameters_cn.html" title="如何调节控制参数"
             accesskey="P">上一页</a> |</li>
        <li><a href="../../index.html">Apollo home</a>&#160;|</li>
        <li><a href="../../contents.html">Documentation</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">HOW TO UNDERSTAND ARCHITECTURE AND WORKFLOW</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">HOW TO UNDERSTAND ARCHITECTURE AND WORKFLOW</a><ul>
<li><a class="reference internal" href="#fundamentals-to-understand-aplloauto-core">Fundamentals to understand AplloAuto - core</a></li>
<li><a class="reference internal" href="#ros-underlying-subscription-and-publication-mechanism-and-apolloauto-modules-structure">ROS underlying Subscription and Publication mechanism and ApolloAuto modules structure</a><ul>
<li><a class="reference internal" href="#ros-underlying-subscription-and-publication-mechanism">ROS underlying Subscription and Publication mechanism</a></li>
<li><a class="reference internal" href="#apolloauto-modules-structure">apolloauto modules structure</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-preprocessing-and-extended-kalman-filter">Data preprocessing and Extended Kalman Filter</a></li>
<li><a class="reference internal" href="#selected-modules-analysis">Selected modules analysis</a><ul>
<li><a class="reference internal" href="#hmi-dreamviewer">HMI &amp; Dreamviewer</a></li>
<li><a class="reference internal" href="#perception">Perception</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="how_to_tune_control_parameters_cn.html"
                        title="上一章">如何调节控制参数</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="how_to_update_vehicle_calibration.html"
                        title="下一章">How to Update Vehicle Calibration for Throttle and Brakes</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/docs/howto/how_to_understand_architecture_and_workflow.md.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section class="tex2jax_ignore mathjax_ignore" id="how-to-understand-architecture-and-workflow">
<h1>HOW TO UNDERSTAND ARCHITECTURE AND WORKFLOW<a class="headerlink" href="#how-to-understand-architecture-and-workflow" title="永久链接至标题">¶</a></h1>
<section id="fundamentals-to-understand-aplloauto-core">
<h2>Fundamentals to understand AplloAuto - core<a class="headerlink" href="#fundamentals-to-understand-aplloauto-core" title="永久链接至标题">¶</a></h2>
<p>Autonomous vehicles (AV) dynamics are controlled by the planning engine through the Controller Area Network bus (CAN bus). The software reads data from hardware registers and writes them back just like we would in Assembly language. For high-precision computation, the Localization, Perception and Planning modules function as independent
input sources, while output sources work together though the Peer2Peer (P2P) protocol. P2P is supported by the RPC network application.</p>
<p>ApolloAuto uses ROS1 as the underlying network which means that ApolloAuto borrows the Master-Nodes framework from ROS1. Since xmlRPC from ROS1 is really old (compared
to the recent brpc and <a class="reference external" href="https://yiakwy.github.io/blog/2017/10/01/gRPC-C-CORE">grpc</a>), Baidu has developed its own protobuf version of RPC.</p>
<p>In Baidu ApolloAuto, three stages of development have already been described</p>
<ol class="simple">
<li><p>Dreamviewer Offline Simulation Engine &amp; ApolloAuto core software module</p>
<ul class="simple">
<li><p>Get a first taste on how the algorithms work for a car</p></li>
<li><p>We don’t need to touch a real car or hardware and start development immediately</p></li>
</ul>
</li>
<li><p>Core modules Integration:</p>
<ul class="simple">
<li><p>Localization</p></li>
<li><p>Perception (support third parties’ solution like Mobileye ES4 chip based camera for L2 development) process point cloud data from <code class="docutils literal notranslate"><span class="pre">Lidar</span></code> and return segmented objects info on request</p></li>
<li><p>Planning: compute the fine-tuned path, car dynamic controlling info for path segments from route service</p></li>
<li><p>Routine: local implementation of finding path segments through <code class="docutils literal notranslate"><span class="pre">Navigator</span></code> interface; Using A*star algorithm.</p></li>
</ul>
</li>
<li><p>HD Maps. One of the key differences from L2 level AV development. L4 AV machine needs Hdmap. Since a robot (an autonomous vehicle ) needs to rebuild
3d world (please check OpenCV <span class="xref myst">SLAM</span> chapter) in its microcomputer, reference object coordinates play a great role in relocating AV both in the map and the real world.</p></li>
<li><p>Cloud-based Online Simulation Drive Scenario Engine and Data Center.</p>
<ul class="simple">
<li><p>As a partner of Baidu, you will be granted docker credentials to commit new images and replay the algorithm you developed on the cloud.</p></li>
<li><p>Create and manage complex scenarios to simulate real-world driving experiences</p></li>
</ul>
</li>
</ol>
</section>
<section id="ros-underlying-subscription-and-publication-mechanism-and-apolloauto-modules-structure">
<h2>ROS underlying Subscription and Publication mechanism and ApolloAuto modules structure<a class="headerlink" href="#ros-underlying-subscription-and-publication-mechanism-and-apolloauto-modules-structure" title="永久链接至标题">¶</a></h2>
<section id="ros-underlying-subscription-and-publication-mechanism">
<h3>ROS underlying Subscription and Publication mechanism<a class="headerlink" href="#ros-underlying-subscription-and-publication-mechanism" title="永久链接至标题">¶</a></h3>
<p>So how does ROS1 based system communicate with each other and how does ApolloAuto make use of it? ROS has <a class="reference external" href="http://wiki.ros.org/ROS/Tutorials">tutorials</a>, and I will explain it
quickly before we analyze ApolloAuto modules structure.</p>
<p>ROS is a software, currently exclusively well supported by Ubuntu series. It has master roscore.</p>
<blockquote>
<div><p>printenv | grep ROS</p>
</div></blockquote>
<p>default ros master uri is “<a class="reference external" href="http://localhost:11311">http://localhost:11311</a>. One can create an independent binary by performing ros::init and start it by performing ros::spin (some kind of Linux event loop)
using c++ or python. The binary behind the freshly created package is called <em><strong>ROS node</strong></em>. The node will register its name and IP address in Master in case of other nodes querying. Nodes communicate
with each by directly constructing a TCP connection.</p>
<p>If a node wants to read data from others, we call it subscriber. The typical format is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="n">bla</span> <span class="n">bla</span> <span class="n">bla</span>
<span class="n">ros</span><span class="p">::</span><span class="n">NodeHandle</span> <span class="n">h</span><span class="p">;</span>
<span class="n">ros</span><span class="p">::</span><span class="n">Subscriber</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="s2">&quot;topic_name&quot;</span><span class="p">,</span> <span class="n">q_size</span><span class="p">,</span> <span class="n">cb</span><span class="p">)</span>
<span class="o">..</span> <span class="n">bla</span> <span class="n">bla</span> <span class="n">bla</span>
</pre></div>
</div>
<p>If a node wants to provide data for subscribers to read, we call it a publisher. The typical format is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="n">bla</span> <span class="n">bla</span> <span class="n">bla</span>
<span class="n">ros</span><span class="p">::</span><span class="n">NodeHandle</span> <span class="n">h</span><span class="p">;</span>
<span class="n">ros</span><span class="p">::</span><span class="n">Publisher</span> <span class="n">pub</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">advertise</span><span class="o">&lt;</span><span class="n">generated_msg_format_cls</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;topic_name&quot;</span><span class="p">,</span> <span class="n">q_size</span><span class="p">)</span>
<span class="o">...</span> <span class="n">bla</span> <span class="n">bla</span> <span class="n">bla</span>
</pre></div>
</div>
<p>cb here is a callback executed when Linux kernel IO is ready. With these signatures bearing in mind, we can quickly analyze ApolloAuto
module structures before diving deep into core modules implementation.</p>
</section>
<section id="apolloauto-modules-structure">
<h3>apolloauto modules structure<a class="headerlink" href="#apolloauto-modules-structure" title="永久链接至标题">¶</a></h3>
<p>I have conducted full research about it but I cannot show you all of them. ApolloAuto modules/common/ provide basic micros to control ros::spin for each
module and /modules/common/adaptor contains the most information on how a topic is registered. Every module will be registered from the <a class="reference external" href="https://github.com/yiakwy/apollo/blob/master/modules/common/adapters/adapter_manager.cc#L50">point</a>
. By reading configuration file defined ${MODULE_NAME}/conf, we can get basic information about topics a module subscribe and publish.</p>
<p>Each module starts by firing “Init” interface and register callbacks. If you want to step by step debug ApolloAuto in gdb, make sure you have added breakpoints in those back. This also
demonstrate that if you don’t like what implemented by Baidu, just override the callback.</p>
</section>
</section>
<section id="data-preprocessing-and-extended-kalman-filter">
<h2>Data preprocessing and Extended Kalman Filter<a class="headerlink" href="#data-preprocessing-and-extended-kalman-filter" title="永久链接至标题">¶</a></h2>
<p>Kalman Filter is mathematical interactive methods to converge to real estimation without knowing the whole real-time input sequence. No matter what kind of data you need to process, you can
rely on Kalman Filter. Extended Kalman Filter is used for 3d rigid movements in a matrix format. It is not hard. I recommend you a series tutorial from United States F15 director
<a class="reference external" href="https://www.youtube.com/watch?v=CaCcOwJPytQ">Michel van Biezen</a>.</p>
<p>Since it is used in input data preprocessing, you might see it in HD Maps, perception, planning and so on so forth.</p>
</section>
<section id="selected-modules-analysis">
<h2>Selected modules analysis<a class="headerlink" href="#selected-modules-analysis" title="永久链接至标题">¶</a></h2>
<section id="hmi-dreamviewer">
<h3>HMI &amp; Dreamviewer<a class="headerlink" href="#hmi-dreamviewer" title="永久链接至标题">¶</a></h3>
<p>There is not too much about hmi interface and dreamviewer but it is a good place to visualize the topics parameters.</p>
<p>HMI is a simply simple python application based on Flask.
Instead of using HTTP, it uses web socket to query ROS modules application. If you have experience on asynchronous HTTP downloaders, it is easy to understand, that an HTTP connection is just a
socket connection file descriptor which we have already write HTTP headers, methods into that buffer. Once hmi flask backend receives a command, it will execute a subprocess
to execute the corresponding binary.</p>
<p>Dreamviewer, in contrast, works a little bit like frontend app written in React, Webpack, and Threejs ( WebGL, see /dreamview/backend/simulation_world, /dreamview/frontend/src/render ),
techniques. It subscribes to messages from ROS nodes and draws it a frame after a frame.</p>
</section>
<section id="perception">
<h3>Perception<a class="headerlink" href="#perception" title="永久链接至标题">¶</a></h3>
<p>Initially, this module implemented logics exclusively for Lidar and Radar processes. It is registered by AdapterManager as a ros node functioning as an info fusion system to
output observed Obstacles info. In the latest version of the codes, different hardware input handlers of ROS nodes are specified in /perception/obstacles/onboard and implemented in
different parallel locations, which consists of <em>Lidar, Radar, Traffic lights and GPS</em>.</p>
<ol class="simple">
<li><p>Lidar:</p>
<ul class="simple">
<li><p>HD Maps: get transformation matrix convert point world coordinates to local coordinates and build map polygons</p></li>
<li><p>ROI filter: get ROI and perform Kalman Filter on input data</p></li>
<li><p>Segmentation: A U-Net based (a lot of variants) Caffe model will be loaded and perform forward computation based on data from HD Maps and ROI filtering results</p></li>
<li><p>Object Building: Lidar return points (x, y, z). Hence you need to group them into “Obstacles” (vector or set)</p></li>
<li><p>Obstacles Tracker: Baidu is using HM solver from Google. For a large bipartite graph, KM algorithms in Lagrange format is usually deployed since
SGD is extremely simple for that.</p></li>
</ul>
</li>
<li><p>Radar:</p>
<ul class="simple">
<li><p>Similar to Lidar with raw_obstacles info from sensors.</p></li>
<li><p>ROI filter: get ROI objects and perform Kalman Filter on input data</p></li>
<li><p>Objects Tracker</p></li>
</ul>
</li>
<li><p>Probability Fusion(New in Apollo 1.5!):</p>
<ul class="simple">
<li><p>As far as I can understand, fusion system in ApolloAuto</p></li>
<li><p>It is typically one of most important parts: collects all the info and makes a final combination of information from sensors on the motherboard
for track lists and rule-based cognitive engine</p></li>
<li><p>The major process is the association, hence HM algorithms here is used again as a bipartite graph.</p></li>
<li><p>Tracklists are maintained along timestamps and each list will be updated based on a probabilistic rules engine</p></li>
</ul>
</li>
</ol>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="how_to_update_vehicle_calibration.html" title="How to Update Vehicle Calibration for Throttle and Brakes"
             >下一页</a> |</li>
        <li class="right" >
          <a href="how_to_tune_control_parameters_cn.html" title="如何调节控制参数"
             >上一页</a> |</li>
        <li><a href="../../index.html">Apollo home</a>&#160;|</li>
        <li><a href="../../contents.html">Documentation</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">HOW TO UNDERSTAND ARCHITECTURE AND WORKFLOW</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2021, xinetzone.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>