
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>路径边界决策 &#8212; Sphinx documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx13.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/tabs.js"></script>
    <script src="../../../_static/translations.js"></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="canonical" href="https://www.sphinx-doc.org/en/master/docs/technical_documents/tasks/path_bounds_decider_cn.html" />
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Sphinx documentation 中搜索"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/favicon.svg"/>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="路径决策" href="path_decider_cn.html" />
    <link rel="prev" title="路径评估决策" href="path_assessment_decider_cn.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script>
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../../../README.html">Home</a></li>
    <li><a href="../../quickstart/README.html">Get it</a></li>
    <li><a href="../../../contents.html">Docs</a></li>
    <li><a href="../../../development/index.html">Extend</a></li>
  </ul>
  <div>
    <a href="../../../README.html">
      <img src="../../../_static/sphinx.png" alt="Apollo Doc" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="path_decider_cn.html" title="路径决策"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="path_assessment_decider_cn.html" title="路径评估决策"
             accesskey="P">上一页</a> |</li>
        <li><a href="../../../index.html">Apollo home</a>&#160;|</li>
        <li><a href="../../../contents.html">Documentation</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">路径边界决策</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">路径边界决策</a><ul>
<li><a class="reference internal" href="#id3">概览</a></li>
<li><a class="reference internal" href="#id4">路径边界决策代码及对应版本</a><ul>
<li><a class="reference internal" href="#id5">类关系</a><ul>
<li><a class="reference internal" href="#id6">（1）继承关系</a></li>
<li><a class="reference internal" href="#id7">（2）调用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">路径边界决策数据</a><ul>
<li><a class="reference internal" href="#id9">（1）输入和输出</a></li>
<li><a class="reference internal" href="#id10">（2）参数设置</a></li>
<li><a class="reference internal" href="#id11">（3）数据结构</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id12">路径边界决策代码流程及框架</a></li>
<li><a class="reference internal" href="#id13">路径边界决策算法解析</a><ul>
<li><a class="reference internal" href="#fallback">1.fallback</a></li>
<li><a class="reference internal" href="#pull-over">2.pull over</a><ul>
<li><a class="reference internal" href="#getboundaryfromroads">（1）GetBoundaryFromRoads</a></li>
<li><a class="reference internal" href="#getboundaryfromstaticobstacles">（2）GetBoundaryFromStaticObstacles</a></li>
<li><a class="reference internal" href="#searchpulloverposition">（3）SearchPullOverPosition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lane-change">3.lane change</a></li>
<li><a class="reference internal" href="#regular">4.Regular</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="path_assessment_decider_cn.html"
                        title="上一章">路径评估决策</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="path_decider_cn.html"
                        title="下一章">路径决策</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/docs/technical_documents/tasks/path_bounds_decider_cn.md.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1><a class="toc-backref" href="#id14">路径边界决策</a><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="id2">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id14">路径边界决策</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id15">概览</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id16">路径边界决策代码及对应版本</a></p>
<ul>
<li><p><a class="reference internal" href="#id5" id="id17">类关系</a></p>
<ul>
<li><p><a class="reference internal" href="#id6" id="id18">（1）继承关系</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id19">（2）调用</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id8" id="id20">路径边界决策数据</a></p>
<ul>
<li><p><a class="reference internal" href="#id9" id="id21">（1）输入和输出</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id22">（2）参数设置</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id23">（3）数据结构</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#id12" id="id24">路径边界决策代码流程及框架</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id25">路径边界决策算法解析</a></p>
<ul>
<li><p><a class="reference internal" href="#fallback" id="id26">1.fallback</a></p></li>
<li><p><a class="reference internal" href="#pull-over" id="id27">2.pull over</a></p>
<ul>
<li><p><a class="reference internal" href="#getboundaryfromroads" id="id28">（1）GetBoundaryFromRoads</a></p></li>
<li><p><a class="reference internal" href="#getboundaryfromstaticobstacles" id="id29">（2）GetBoundaryFromStaticObstacles</a></p></li>
<li><p><a class="reference internal" href="#searchpulloverposition" id="id30">（3）SearchPullOverPosition</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#lane-change" id="id31">3.lane change</a></p></li>
<li><p><a class="reference internal" href="#regular" id="id32">4.Regular</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="id3">
<h2><a class="toc-backref" href="#id15">概览</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">路径边界决策</span></code>是规划模块的任务，属于task中的decider类别。</p>
<p>规划模块的运动总体流程图如下：</p>
<p><img alt="总体流程图" src="../../../_images/lane_follow.png" /></p>
<p>总体流程图以<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/conf/scenario/lane_follow_config.pb.txt">lane follow</a>场景为例子进行说明。这里只说明主体的流程，不涉及到所有细节。task的主要功能位于<code class="docutils literal notranslate"><span class="pre">Process</span></code>函数中。</p>
<p>第一，规划模块的入口函数是PlanningComponent的<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/planning_component.cc#L118">Proc</a>。</p>
<p>第二，以规划模式OnLanePlanning，执行<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/on_lane_planning.cc#L205">RunOnce</a>。在RunOnce中先执行交通规则，再规划轨迹。规划轨迹的函数是<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/on_lane_planning.cc#L487">Plan</a>。</p>
<p>第三，进入到PublicRoadPlanner中的<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/planner/public_road/public_road_planner.cc#L33">Plan</a>函数，进行轨迹规划。ScenarioManager的<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/scenarios/scenario_manager.cc#L798">Update</a>函数根据当前的scenario_type选择合适的场景。这里的流程图是以lane follow为例。</p>
<p>第四，选择lane follow的场景后，执行<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/scenarios/scenario.cc#L66">Process</a>函数。然后，执行LaneFollowStage中的<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/scenarios/lane_follow/lane_follow_stage.cc#L93">Process</a>函数，在<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/scenarios/lane_follow/lane_follow_stage.cc#L153">PlanOnReferenceLine</a>中执行LaneFollowStage中的所有的task。通过调用<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/scenarios/lane_follow/lane_follow_stage.cc#L167">Excute</a>函数执行task，Excute调用了task的<a class="reference external" href="https://github.com/ApolloAuto/apollo/blob/r6.0.0/modules/planning/tasks/deciders/decider.cc#L37">Process</a>（以decider为例子）函数。最后一个图中，TaskType指的不是具体的类名称，代表所有的task类型。虚线的箭头，表示在LaneFollowStage中按照vector中的顺序执行所有的任务。</p>
<p>最后，Task的流程都在Process函数中。之后对task的讲解都从Process函数开始。</p>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id16">路径边界决策代码及对应版本</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>本节说明path_bounds_decider任务。</p>
<p>请参考 <a class="reference external" href="https://github.com/ApolloAuto/apollo/tree/r6.0.0/modules/planning/tasks/deciders/path_bounds_decider">Apollo r6.0.0 path_bounds_decider</a></p>
<section id="id5">
<h3><a class="toc-backref" href="#id17">类关系</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p><img alt="path_bounds_decider_task" src="../../../_images/task.png" /></p>
<section id="id6">
<h4><a class="toc-backref" href="#id18">（1）继承关系</a><a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>① <code class="docutils literal notranslate"><span class="pre">PathBoundsDecider</span></code>类继承<code class="docutils literal notranslate"><span class="pre">Decider</span></code>类，实现了<code class="docutils literal notranslate"><span class="pre">Process</span></code>方法，路径边界决策主要的执行过程就在<code class="docutils literal notranslate"><span class="pre">process</span></code>方法中。</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/tasks/deciders/path_bounds_decider/path_bounds_decider.h</span>
<span class="k">class</span> <span class="nc">PathBoundsDecider</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Decider</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">...</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>② <code class="docutils literal notranslate"><span class="pre">Decider</span></code>类继承<code class="docutils literal notranslate"><span class="pre">Task</span></code>类，实现类Excute方法，主要是给两个变量赋值：<code class="docutils literal notranslate"><span class="pre">frame</span></code>和<code class="docutils literal notranslate"><span class="pre">reference_line_info</span></code>，并且执行<strong>Process</strong>方法。对应了上述的<strong>Process</strong>方法</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/tasks/deciders/decider.h</span>
<span class="k">class</span> <span class="nc">Decider</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Task</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">...</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">// modules/planning/tasks/deciders/decider.cc</span>
<span class="n">apollo</span><span class="o">::</span><span class="n">common</span><span class="o">::</span><span class="n">Status</span><span class="w"> </span><span class="nf">Decider::Execute</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">ReferenceLineInfo</span><span class="o">*</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Task</span><span class="o">::</span><span class="n">Execute</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">apollo</span><span class="o">::</span><span class="n">common</span><span class="o">::</span><span class="n">Status</span><span class="w"> </span><span class="nf">Decider::Execute</span><span class="p">(</span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Task</span><span class="o">::</span><span class="n">Execute</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>③ <code class="docutils literal notranslate"><span class="pre">Task</span></code>类，定义类保护类型的变量，是路径边界决策的输入</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/tasks/task.h</span>
<span class="k">class</span> <span class="nc">Task</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 虚方法，主要是给frame和reference_line_info赋值</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">Status</span><span class="w"> </span><span class="n">Execute</span><span class="p">(</span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">ReferenceLineInfo</span><span class="o">*</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">Status</span><span class="w"> </span><span class="nf">Execute</span><span class="p">(</span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// frame和reference_line_info变量</span>
<span class="w">  </span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ReferenceLineInfo</span><span class="o">*</span><span class="w"> </span><span class="n">reference_line_info_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 配置与名字</span>
<span class="w">  </span><span class="n">TaskConfig</span><span class="w"> </span><span class="n">config_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name_</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id7">
<h4><a class="toc-backref" href="#id19">（2）调用</a><a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>主要描述task在stage中是如何创建和调用的</p>
<p>① <code class="docutils literal notranslate"><span class="pre">TaskFactory</span></code>类，注册所有的task，包括decider、optimizer和other（E2E的task）。工厂模式</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/tasks/task_factory.h</span>
<span class="k">class</span> <span class="nc">TaskFactory</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 两个函数都是static属性</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Init</span><span class="p">(...);</span><span class="w">    </span><span class="c1">// 在初始化函数中，注册所有的task</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CreateTask</span><span class="p">(...);</span><span class="w">    </span><span class="c1">// 创建具体task的实例，返回指向该实例的指针</span>
<span class="p">...</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>② stage中task的创建与执行</p>
<ul class="simple">
<li><p>创建：在stage的构造函数中根据stage配置创建task。并将指针放入到task_和task_list_中</p></li>
<li><p>使用：在具体的stage中，重写Process方法。调用Process方法，进而调用ExecuteTask*方法（ExecuteTaskOnReferenceLine），最后调用相应的task的Process方法</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/scenarios/stage.h</span>
<span class="k">class</span> <span class="nc">Stage</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="c1">// 在构造函数中根据stage的配置创建task</span>
<span class="w"> </span><span class="n">Stage</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ScenarioConfig</span><span class="o">::</span><span class="n">StageConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">config</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DependencyInjector</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">injector</span><span class="p">);</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>

<span class="w"> </span><span class="c1">// 纯虚函数，留给具体的stage实现，不同的stage有不同的实现逻辑</span>
<span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">StageStatus</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">TrajectoryPoint</span><span class="o">&amp;</span><span class="w"> </span><span class="n">planning_init_point</span><span class="p">,</span><span class="w"> </span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 三个执行task的函数，在每个函数中都调用类task的Excute方法，进一步调用具体task的Process方法</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">ExecuteTaskOnReferenceLine</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">TrajectoryPoint</span><span class="o">&amp;</span><span class="w"> </span><span class="n">planning_start_point</span><span class="p">,</span><span class="w"> </span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">ExecuteTaskOnReferenceLineForOnlineLearning</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">TrajectoryPoint</span><span class="o">&amp;</span><span class="w"> </span><span class="n">planning_start_point</span><span class="p">,</span><span class="w"> </span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">ExecuteTaskOnOpenSpace</span><span class="p">(</span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// task的map，key是TaskType，value是指向Task的指针</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">TaskConfig</span><span class="o">::</span><span class="n">TaskType</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">tasks_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 保存Task列表</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">task_list_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// stage 配置</span>
<span class="w">  </span><span class="n">ScenarioConfig</span><span class="o">::</span><span class="n">StageConfig</span><span class="w"> </span><span class="n">config_</span><span class="p">;</span><span class="w"></span>
<span class="p">...};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id20">路径边界决策数据</a><a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">PathBoundsDecider</span></code>类主要的输入、输出，数据结构，变量设置。</p>
<section id="id9">
<h4><a class="toc-backref" href="#id21">（1）输入和输出</a><a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>① 输入有两个：<code class="docutils literal notranslate"><span class="pre">frame</span></code>与<code class="docutils literal notranslate"><span class="pre">reference_line_info</span></code></p>
<ul class="simple">
<li><p><strong>frame</strong></p></li>
</ul>
<p>frame中包含的一次规划所需要的所有的数据</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/common/frame.h</span>
<span class="k">class</span> <span class="nc">Frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">DrivingAction</span><span class="w"> </span><span class="n">pad_msg_driving_action_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">sequence_num_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* Local_view是一个结构体，包含了如下信息</span>
<span class="cm">  // modules/planning/common/local_view.h</span>
<span class="cm">  struct LocalView {</span>
<span class="cm">    std::shared_ptr&lt;prediction::PredictionObstacles&gt; prediction_obstacles;</span>
<span class="cm">    std::shared_ptr&lt;canbus::Chassis&gt; chassis;</span>
<span class="cm">    std::shared_ptr&lt;localization::LocalizationEstimate&gt; localization_estimate;</span>
<span class="cm">    std::shared_ptr&lt;perception::TrafficLightDetection&gt; traffic_light;</span>
<span class="cm">    std::shared_ptr&lt;routing::RoutingResponse&gt; routing;</span>
<span class="cm">    std::shared_ptr&lt;relative_map::MapMsg&gt; relative_map;</span>
<span class="cm">    std::shared_ptr&lt;PadMessage&gt; pad_msg;</span>
<span class="cm">    std::shared_ptr&lt;storytelling::Stories&gt; stories;</span>
<span class="cm">  };</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="n">LocalView</span><span class="w"> </span><span class="n">local_view_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 高清地图</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">hdmap</span><span class="o">::</span><span class="n">HDMap</span><span class="w"> </span><span class="o">*</span><span class="n">hdmap_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">common</span><span class="o">::</span><span class="n">TrajectoryPoint</span><span class="w"> </span><span class="n">planning_start_point_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 车辆状态</span>
<span class="w">  </span><span class="c1">// modules/common/vehicle_state/proto/vehicle_state.proto</span>
<span class="w">  </span><span class="n">common</span><span class="o">::</span><span class="n">VehicleState</span><span class="w"> </span><span class="n">vehicle_state_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 参考线信息</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">ReferenceLineInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">reference_line_info_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_near_destination_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * the reference line info that the vehicle finally choose to drive on</span>
<span class="cm">   **/</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ReferenceLineInfo</span><span class="w"> </span><span class="o">*</span><span class="n">drive_reference_line_info_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">ThreadSafeIndexedObstacles</span><span class="w"> </span><span class="n">obstacles_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">perception</span><span class="o">::</span><span class="n">TrafficLight</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">traffic_lights_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// current frame published trajectory</span>
<span class="w">  </span><span class="n">ADCTrajectory</span><span class="w"> </span><span class="n">current_frame_planned_trajectory_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// current frame path for future possible speed fallback</span>
<span class="w">  </span><span class="n">DiscretizedPath</span><span class="w"> </span><span class="n">current_frame_planned_path_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ReferenceLineProvider</span><span class="w"> </span><span class="o">*</span><span class="n">reference_line_provider_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">OpenSpaceInfo</span><span class="w"> </span><span class="n">open_space_info_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">routing</span><span class="o">::</span><span class="n">LaneWaypoint</span><span class="o">&gt;</span><span class="w"> </span><span class="n">future_route_waypoints_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">common</span><span class="o">::</span><span class="n">monitor</span><span class="o">::</span><span class="n">MonitorLogBuffer</span><span class="w"> </span><span class="n">monitor_logger_buffer_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>reference_line_info</strong></p></li>
</ul>
<p>reference_line_info包含了有关reference_line的所有的数据</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/common/reference_line_info.h</span>

<span class="k">class</span> <span class="nc">ReferenceLineInfo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">junction_right_of_way_map_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">VehicleState</span><span class="w"> </span><span class="n">vehicle_state_</span><span class="p">;</span><span class="w">  </span><span class="c1">// 车辆状态</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">TrajectoryPoint</span><span class="w"> </span><span class="n">adc_planning_point_</span><span class="p">;</span><span class="w">  </span><span class="c1">// TrajectoryPoint定义在modules/common/proto/pnc_point.proto中</span>

<span class="w">  </span><span class="cm">/* 参考线，以道路中心线，做过顺滑的一条轨迹，往后80米，往前130米。</span>
<span class="cm">  class ReferenceLine {</span>
<span class="cm">  ...</span>
<span class="cm">  private:</span>
<span class="cm">  struct SpeedLimit {</span>
<span class="cm">    double start_s = 0.0;</span>
<span class="cm">    double end_s = 0.0;</span>
<span class="cm">    double speed_limit = 0.0;  // unit m/s</span>
<span class="cm">    ...};</span>
<span class="cm">  </span>
<span class="cm">  // This speed limit overrides the lane speed limit</span>
<span class="cm">  std::vector&lt;SpeedLimit&gt; speed_limit_;</span>
<span class="cm">  std::vector&lt;ReferencePoint&gt; reference_points_;  // ReferencePoint包含有信息(k, dk, x, y, heading, s, l)</span>
<span class="cm">  hdmap::Path map_path_;</span>
<span class="cm">  uint32_t priority_ = 0;</span>
<span class="cm">  };</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="n">ReferenceLine</span><span class="w"> </span><span class="n">reference_line_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * @brief this is the number that measures the goodness of this reference</span>
<span class="cm">   * line. The lower the better.</span>
<span class="cm">   */</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 评价函数，值越低越好</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">cost_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_drivable_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// PathDecision包含了一条路径上的所有obstacle的决策，有两种：lateral(Nudge, Ignore)和longitudinal(Stop, Yield, Follow, Overtake, Ignore)</span>
<span class="w">  </span><span class="n">PathDecision</span><span class="w"> </span><span class="n">path_decision_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 指针</span>
<span class="w">  </span><span class="n">Obstacle</span><span class="o">*</span><span class="w"> </span><span class="n">blocking_obstacle_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* path的边界，结果保存在这个变量里。通过**SetCandidatePathBoundaries**方法保存到此变量</span>
<span class="cm">    // modules/planning/common/path_boundary.h</span>
<span class="cm">    class PathBoundary {</span>
<span class="cm">    ...</span>
<span class="cm">      private:</span>
<span class="cm">     double start_s_ = 0.0;</span>
<span class="cm">     double delta_s_ = 0.0;</span>
<span class="cm">     std::vector&lt;std::pair&lt;double, double&gt;&gt; boundary_;</span>
<span class="cm">     std::string label_ = &quot;regular&quot;;</span>
<span class="cm">     std::string blocking_obstacle_id_ = &quot;&quot;;</span>
<span class="cm">  };</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathBoundary</span><span class="o">&gt;</span><span class="w"> </span><span class="n">candidate_path_boundaries_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// PathData类，包含XY坐标系和SL坐标系的相互转化</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">candidate_path_data_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">PathData</span><span class="w"> </span><span class="n">path_data_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">PathData</span><span class="w"> </span><span class="n">fallback_path_data_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">SpeedData</span><span class="w"> </span><span class="n">speed_data_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">DiscretizedTrajectory</span><span class="w"> </span><span class="n">discretized_trajectory_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">RSSInfo</span><span class="w"> </span><span class="n">rss_info_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * @brief SL boundary of stitching point (starting point of plan trajectory)</span>
<span class="cm">   * relative to the reference line</span>
<span class="cm">   */</span><span class="w"></span>
<span class="w">  </span><span class="n">SLBoundary</span><span class="w"> </span><span class="n">adc_sl_boundary_</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>② 输出：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">Status</span><span class="w"> </span><span class="n">PathBoundsDecider</span><span class="o">::</span><span class="n">Process</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">Frame</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">ReferenceLineInfo</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Process 函数定义，最终结果保存到了<code class="docutils literal notranslate"><span class="pre">reference_line_info</span></code>中</p>
</section>
<section id="id10">
<h4><a class="toc-backref" href="#id22">（2）参数设置</a><a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/tasks/deciders/path_bounds_decider/path_bounds_decider.cc</span>
<span class="c1">// s方向的距离</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kPathBoundsDeciderHorizon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">100.0</span><span class="p">;</span><span class="w"></span>
<span class="c1">// s方向的间隔</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kPathBoundsDeciderResolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Lane宽度</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kDefaultLaneWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Road的道路</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kDefaultRoadWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// TODO(all): Update extra tail point base on vehicle speed.</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kNumExtraTailBoundPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kPulloverLonSearchCoeff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5</span><span class="p">;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kPulloverLatSearchCoeff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.25</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id11">
<h4><a class="toc-backref" href="#id23">（3）数据结构</a><a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// modules/planning/tasks/deciders/path_bounds_decider/path_bounds_decider.cc</span>
<span class="k">namespace</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="c1">// PathBoundPoint contains: (s, l_min, l_max). 路径边界点</span>
<span class="k">using</span><span class="w"> </span><span class="n">PathBoundPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="c1">// PathBound contains a vector of PathBoundPoints. 路径边界</span>
<span class="k">using</span><span class="w"> </span><span class="n">PathBound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathBoundPoint</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="c1">// ObstacleEdge contains: (is_start_s, s, l_min, l_max, obstacle_id). 障碍物的边</span>
<span class="k">using</span><span class="w"> </span><span class="n">ObstacleEdge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="id12">
<h2><a class="toc-backref" href="#id24">路径边界决策代码流程及框架</a><a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>Fig.2是路径边界决策的流程图。</p>
<p><img alt="path_bounds_decider" src="../../../_images/path_bounds_decider.png" /></p>
<p>在<strong>Process</strong>方法中，分四种场景对路径边界进行计算，按照处理的顺序分别是：fallback，pull-over，lane-change，regular。
其中regular场景根据是否借道又分为LEFT_BORROW, NO_BORROW, RIGHT_BORROW。</p>
<p>fallback场景的path bounds一定会生成，另外三种看情况，都是需要if判断。</p>
</section>
<section id="id13">
<h2><a class="toc-backref" href="#id25">路径边界决策算法解析</a><a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<section id="fallback">
<h3><a class="toc-backref" href="#id26">1.fallback</a><a class="headerlink" href="#fallback" title="永久链接至标题">¶</a></h3>
<p><img alt="fallback" src="../../../_images/fallback.png" /></p>
<p>fallback场景生成过程如上图所示。
fallback只考虑adc信息和静态道路信息，主要调用两个函数</p>
<ul class="simple">
<li><p>InitPathBoundary</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">PathBoundsDecider</span><span class="o">::</span><span class="n">InitPathBoundary</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Starting from ADC&#39;s current position, increment until the horizon, and</span>
<span class="w">  </span><span class="c1">// set lateral bounds to be infinite at every spot.</span>
<span class="w">  </span><span class="c1">// 从adc当前位置开始，以0.5m为间隔取点，直到终点，将 [左, 右] 边界设置为double的 [lowerst, max]</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">curr_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adc_frenet_s_</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">curr_s</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">fmin</span><span class="p">(</span><span class="n">adc_frenet_s_</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">                              </span><span class="n">std</span><span class="o">::</span><span class="n">fmax</span><span class="p">(</span><span class="n">kPathBoundsDeciderHorizon</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">reference_line_info</span><span class="p">.</span><span class="n">GetCruiseSpeed</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                                            </span><span class="n">FLAGS_trajectory_time_length</span><span class="p">),</span><span class="w"></span>
<span class="w">                          </span><span class="n">reference_line</span><span class="p">.</span><span class="n">Length</span><span class="p">());</span><span class="w"></span>
<span class="w">       </span><span class="n">curr_s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">kPathBoundsDeciderResolution</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">path_bound</span><span class="o">-&gt;</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">curr_s</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">lowest</span><span class="p">(),</span><span class="w"></span>
<span class="w">                             </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">...}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>GetBoundaryFromLanesAndADC</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// TODO(jiacheng): this function is to be retired soon.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">PathBoundsDecider</span><span class="o">::</span><span class="n">GetBoundaryFromLanesAndADC</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">path_bound</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 1. Get the current lane width at current point.获取当前点车道的宽度</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">reference_line</span><span class="p">.</span><span class="n">GetLaneWidth</span><span class="p">(</span><span class="n">curr_s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">curr_lane_left_width</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="o">&amp;</span><span class="n">curr_lane_right_width</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AWARN</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to get lane width at s = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">curr_s</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_lane_left_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">past_lane_left_width</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_lane_right_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">past_lane_right_width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 2. Get the neighbor lane widths at the current point.获取当前点相邻车道的宽度</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_neighbor_lane_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CheckLaneBoundaryType</span><span class="p">(</span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"> </span><span class="n">curr_s</span><span class="p">,</span><span class="w"> </span><span class="n">lane_borrow_info</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">hdmap</span><span class="o">::</span><span class="n">Id</span><span class="w"> </span><span class="n">neighbor_lane_id</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_borrow_info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LaneBorrowInfo</span><span class="o">::</span><span class="n">LEFT_BORROW</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 借左车道</span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_borrow_info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LaneBorrowInfo</span><span class="o">::</span><span class="n">RIGHT_BORROW</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 借右车道</span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 3. 根据道路宽度，adc的位置和速度计算合适的边界。</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kMaxLateralAccelerations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_to_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">reference_line</span><span class="p">.</span><span class="n">GetOffsetToMap</span><span class="p">(</span><span class="n">curr_s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">offset_to_map</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">ADC_speed_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">adc_frenet_ld_</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                              </span><span class="n">adc_frenet_ld_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adc_frenet_ld_</span><span class="w"> </span><span class="o">/</span><span class="w"></span>
<span class="w">                              </span><span class="n">kMaxLateralAccelerations</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 向左车道借到，左边界会变成左侧车道左边界</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_left_bound_lane</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">curr_lane_left_width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">lane_borrow_info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LaneBorrowInfo</span><span class="o">::</span><span class="n">LEFT_BORROW</span><span class="w"></span>
<span class="w">                                    </span><span class="o">?</span><span class="w"> </span><span class="nl">curr_neighbor_lane_width</span>
                                    <span class="p">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 和上面类似</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_right_bound_lane</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="o">-</span><span class="n">curr_lane_right_width</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">lane_borrow_info</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LaneBorrowInfo</span><span class="o">::</span><span class="n">RIGHT_BORROW</span><span class="w"></span>
<span class="w">             </span><span class="o">?</span><span class="w"> </span><span class="nl">curr_neighbor_lane_width</span>
             <span class="p">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_left_bound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 左边界</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_right_bound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 右边界</span>
<span class="w">    </span><span class="c1">// 计算左边界和右边界</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">config_</span><span class="p">.</span><span class="n">path_bounds_decider_config</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">is_extend_lane_bounds_to_include_adc</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">        </span><span class="n">is_fallback_lanechange</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// extend path bounds to include ADC in fallback or change lane path</span>
<span class="w">      </span><span class="c1">// bounds.</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_left_bound_adc</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">fmax</span><span class="p">(</span><span class="n">adc_l_to_lane_center_</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">adc_l_to_lane_center_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ADC_speed_buffer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">          </span><span class="n">GetBufferBetweenADCCenterAndEdge</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ADC_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_left_bound</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">fmax</span><span class="p">(</span><span class="n">curr_left_bound_lane</span><span class="p">,</span><span class="w"> </span><span class="n">curr_left_bound_adc</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset_to_map</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_right_bound_adc</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">fmin</span><span class="p">(</span><span class="n">adc_l_to_lane_center_</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">adc_l_to_lane_center_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ADC_speed_buffer</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">          </span><span class="n">GetBufferBetweenADCCenterAndEdge</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ADC_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_right_bound</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">fmin</span><span class="p">(</span><span class="n">curr_right_bound_lane</span><span class="p">,</span><span class="w"> </span><span class="n">curr_right_bound_adc</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">          </span><span class="n">offset_to_map</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_left_bound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_left_bound_lane</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset_to_map</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_right_bound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_right_bound_lane</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset_to_map</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 4. 更新边界.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">UpdatePathBoundaryWithBuffer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">curr_left_bound</span><span class="p">,</span><span class="w"> </span><span class="n">curr_right_bound</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">path_bound</span><span class="p">,</span><span class="w"> </span><span class="n">is_left_lane_boundary</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">is_right_lane_boundary</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">path_blocked_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="pull-over">
<h3><a class="toc-backref" href="#id27">2.pull over</a><a class="headerlink" href="#pull-over" title="永久链接至标题">¶</a></h3>
<p><img alt="pull_over" src="../../../_images/pull_over.png" /></p>
<section id="getboundaryfromroads">
<h4><a class="toc-backref" href="#id28">（1）GetBoundaryFromRoads</a><a class="headerlink" href="#getboundaryfromroads" title="永久链接至标题">¶</a></h4>
<p>与<code class="docutils literal notranslate"><span class="pre">GetBoundaryFromLanesAndADC</span></code>不同，<code class="docutils literal notranslate"><span class="pre">GetBoundaryFromRoads</span></code>函数根据道路信息计算出边界:</p>
<ul class="simple">
<li><p>获取参考线信息</p></li>
<li><p>对路径上的点，逐点计算</p>
<ul>
<li><p>边界</p></li>
<li><p>更新</p></li>
</ul>
</li>
</ul>
</section>
<section id="getboundaryfromstaticobstacles">
<h4><a class="toc-backref" href="#id29">（2）GetBoundaryFromStaticObstacles</a><a class="headerlink" href="#getboundaryfromstaticobstacles" title="永久链接至标题">¶</a></h4>
<p>根据障碍车调整边界：</p>
<ul class="simple">
<li><p>计算障碍车在frenet坐标系下的坐标</p></li>
<li><p>扫描线排序，S方向扫描</p>
<ul>
<li><p>只关注在路径边界内的障碍物</p></li>
<li><p>只关注在adc前方的障碍物</p></li>
<li><p>将障碍物分解为两个边界，开始和结束</p></li>
</ul>
</li>
<li><p>映射障碍物ID</p>
<ul>
<li><p>Adc能从左边通过为True，否则为False</p></li>
</ul>
</li>
<li><p>逐个点的检查path路径上的障碍物</p>
<ul>
<li><p>根据新来的障碍物</p></li>
<li><p>根据已有的障碍物</p></li>
</ul>
</li>
</ul>
</section>
<section id="searchpulloverposition">
<h4><a class="toc-backref" href="#id30">（3）SearchPullOverPosition</a><a class="headerlink" href="#searchpulloverposition" title="永久链接至标题">¶</a></h4>
<p>搜索pull over位置的过程：</p>
<ul class="simple">
<li><p>根据pull_over_status.pull_over_type()判断是前向搜索（pull over开头第一个点），还是后向搜索（pull over末尾后一个点）</p></li>
<li><p>两层循环，外层控制搜索的索引idx，内层控制进一步的索引（前向idx+1，后向idx-1）。</p></li>
<li><p>根据内外两层循环的索引，判断搜索到的空间是否满足宽度和长度要求，判断是否可以pull over</p></li>
</ul>
<p>代码如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">PathBoundsDecider::SearchPullOverPosition</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Frame</span><span class="o">&amp;</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ReferenceLineInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">path_bound</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pull_over_configuration</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pull_over_status</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">injector_</span><span class="o">-&gt;</span><span class="n">planning_context</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">planning_status</span><span class="p">().</span><span class="n">pull_over</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 搜索方向，默认前向搜索</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">search_backward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// search FORWARD by default</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">pull_over_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pull_over_status</span><span class="p">.</span><span class="n">pull_over_type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"></span>
<span class="w">      </span><span class="n">PullOverStatus</span><span class="o">::</span><span class="n">EMERGENCY_PULL_OVER</span><span class="p">)</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">search_backward</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 后向搜索，定位pull over末尾的一个点.</span>
<span class="w">    </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">pull_over_s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">--</span><span class="n">idx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 前向搜索，定位emergency pull over开头后的第一个点.</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">           </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pull_over_s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">idx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 为pull over搜索到一个可行的位置，主要是确定该区域的宽度和长度</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">pull_over_space_length</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">kPulloverLonSearchCoeff</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">          </span><span class="n">VehicleConfigHelper</span><span class="o">::</span><span class="n">GetConfig</span><span class="p">().</span><span class="n">vehicle_param</span><span class="p">().</span><span class="n">length</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">      </span><span class="n">FLAGS_obstacle_lon_start_buffer</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">FLAGS_obstacle_lon_end_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">pull_over_space_width</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">kPulloverLatSearchCoeff</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">      </span><span class="n">VehicleConfigHelper</span><span class="o">::</span><span class="n">GetConfig</span><span class="p">().</span><span class="n">vehicle_param</span><span class="p">().</span><span class="n">width</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">adc_half_width</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">VehicleConfigHelper</span><span class="o">::</span><span class="n">GetConfig</span><span class="p">().</span><span class="n">vehicle_param</span><span class="p">().</span><span class="n">width</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. Find a window that is close to road-edge.</span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">    这里用了内外两层循环进行搜索，外层循环控制搜索的开始的端点idx。</span>
<span class="cm">    内层控制另一个端点。根据找到的两个端点，判断区域是否可以pull over</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_a_feasible_window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">search_backward</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">.</span><span class="n">front</span><span class="p">())</span><span class="w"> </span><span class="o">&gt;</span><span class="w"></span>
<span class="w">              </span><span class="n">pull_over_space_length</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">         </span><span class="p">(</span><span class="o">!</span><span class="n">search_backward</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">.</span><span class="n">back</span><span class="p">())</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;</span><span class="w"></span>
<span class="w">              </span><span class="n">pull_over_space_length</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">search_backward</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"></span>
<span class="w">                </span><span class="n">pull_over_space_length</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">           </span><span class="p">(</span><span class="o">!</span><span class="n">search_backward</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_bound</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"></span>
<span class="w">                </span><span class="n">pull_over_space_length</span><span class="p">))</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 找到可行区域，获取停车区域的位置和姿态</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_feasible_window</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;}</span><span class="w"></span>
<span class="w">    </span><span class="p">...}</span><span class="w">  </span><span class="c1">// 外层while</span>
<span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="lane-change">
<h3><a class="toc-backref" href="#id31">3.lane change</a><a class="headerlink" href="#lane-change" title="永久链接至标题">¶</a></h3>
<p><img alt="lane_change" src="../../../_images/lane_change.png" /></p>
<p>代码流程如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">Status</span><span class="w"> </span><span class="nf">PathBoundsDecider::GenerateLaneChangePathBound</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ReferenceLineInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&gt;*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">path_bound</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1.初始化，和前面的步骤类似</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">InitPathBoundary</span><span class="p">(</span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"> </span><span class="n">path_bound</span><span class="p">))</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>


<span class="w">  </span><span class="c1">// 2. 根据道路和adc的信息获取一个大致的路径边界</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">dummy_borrow_lane_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">GetBoundaryFromLanesAndADC</span><span class="p">(</span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">LaneBorrowInfo</span><span class="o">::</span><span class="n">NO_BORROW</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="n">path_bound</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="o">&amp;</span><span class="n">dummy_borrow_lane_type</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">))</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>
<span class="w"> </span>

<span class="w">  </span><span class="c1">// 3. Remove the S-length of target lane out of the path-bound.</span>
<span class="w">  </span><span class="n">GetBoundaryFromLaneChangeForbiddenZone</span><span class="p">(</span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"> </span><span class="n">path_bound</span><span class="p">);</span><span class="w"></span>


<span class="w">  </span><span class="c1">// 根据静态障碍物调整边界.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">GetBoundaryFromStaticObstacles</span><span class="p">(</span><span class="n">reference_line_info</span><span class="p">.</span><span class="n">path_decision</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                      </span><span class="n">path_bound</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">blocking_obstacle_id</span><span class="p">))</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>GetBoundaryFromLaneChangeForbiddenZone函数是lane change重要的函数。运行过程如下：</p>
<ul class="simple">
<li><p>如果当前位置可以变道，则直接变道</p></li>
<li><p>如果有一个lane-change的起点，则直接使用它</p></li>
<li><p>逐个检查变道前的点的边界，改变边界的值（如果已经过了变道点，则返回）</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">PathBoundsDecider::GetBoundaryFromLaneChangeForbiddenZone</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ReferenceLineInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"> </span><span class="n">PathBound</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">path_bound</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>


<span class="w">  </span><span class="c1">// 1.当前位置直接变道。</span>
<span class="w">  </span><span class="k">auto</span><span class="o">*</span><span class="w"> </span><span class="n">lane_change_status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">injector_</span><span class="o">-&gt;</span><span class="n">planning_context</span><span class="p">()</span><span class="w"></span>
<span class="w">                                 </span><span class="o">-&gt;</span><span class="n">mutable_planning_status</span><span class="p">()</span><span class="w"></span>
<span class="w">                                 </span><span class="o">-&gt;</span><span class="n">mutable_change_lane</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_change_status</span><span class="o">-&gt;</span><span class="n">is_clear_to_change_lane</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Current position is clear to change lane. No need prep s.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_change_status</span><span class="o">-&gt;</span><span class="n">set_exist_lane_change_start_position</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="c1">// 2.如果已经有一个lane-change的起点，就直接使用它，否则再找一个</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">lane_change_start_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_change_status</span><span class="o">-&gt;</span><span class="n">exist_lane_change_start_position</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">common</span><span class="o">::</span><span class="n">SLPoint</span><span class="w"> </span><span class="n">point_sl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">reference_line</span><span class="p">.</span><span class="n">XYToSL</span><span class="p">(</span><span class="n">lane_change_status</span><span class="o">-&gt;</span><span class="n">lane_change_start_position</span><span class="p">(),</span><span class="w"></span>
<span class="w">                          </span><span class="o">&amp;</span><span class="n">point_sl</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_change_start_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_sl</span><span class="p">.</span><span class="n">s</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// TODO(jiacheng): train ML model to learn this.</span>
<span class="w">    </span><span class="c1">// 设置为adc前方一段距离为变道起始点</span>
<span class="w">    </span><span class="n">lane_change_start_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FLAGS_lane_change_prepare_length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">adc_frenet_s_</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Update the decided lane_change_start_s into planning-context.</span>
<span class="w">    </span><span class="c1">// 更新变道起始点的信息</span>
<span class="w">    </span><span class="n">common</span><span class="o">::</span><span class="n">SLPoint</span><span class="w"> </span><span class="n">lane_change_start_sl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_change_start_sl</span><span class="p">.</span><span class="n">set_s</span><span class="p">(</span><span class="n">lane_change_start_s</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_change_start_sl</span><span class="p">.</span><span class="n">set_l</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">common</span><span class="o">::</span><span class="n">math</span><span class="o">::</span><span class="n">Vec2d</span><span class="w"> </span><span class="n">lane_change_start_xy</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">reference_line</span><span class="p">.</span><span class="n">SLToXY</span><span class="p">(</span><span class="n">lane_change_start_sl</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lane_change_start_xy</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_change_status</span><span class="o">-&gt;</span><span class="n">set_exist_lane_change_start_position</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_change_status</span><span class="o">-&gt;</span><span class="n">mutable_lane_change_start_position</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_x</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">lane_change_start_xy</span><span class="p">.</span><span class="n">x</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_change_status</span><span class="o">-&gt;</span><span class="n">mutable_lane_change_start_position</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_y</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">lane_change_start_xy</span><span class="p">.</span><span class="n">y</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Remove the target lane out of the path-boundary, up to the decided S.</span>
<span class="w">  </span><span class="c1">// 逐个检查变道前的点的边界，改变边界的值</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">path_bound</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr_s</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">lane_change_start_s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_lane_left_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_lane_right_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_to_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">reference_line</span><span class="p">.</span><span class="n">GetOffsetToMap</span><span class="p">(</span><span class="n">curr_s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">offset_to_map</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reference_line</span><span class="p">.</span><span class="n">GetLaneWidth</span><span class="p">(</span><span class="n">curr_s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">curr_lane_left_width</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="o">&amp;</span><span class="n">curr_lane_right_width</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_to_lane_center</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">reference_line</span><span class="p">.</span><span class="n">GetOffsetToMap</span><span class="p">(</span><span class="n">curr_s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">offset_to_lane_center</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_lane_left_width</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">offset_to_lane_center</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_lane_right_width</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">offset_to_lane_center</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">curr_lane_left_width</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">offset_to_map</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">curr_lane_right_width</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">offset_to_map</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">adc_frenet_l_</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">curr_lane_left_width</span><span class="w"></span>
<span class="w">            </span><span class="o">?</span><span class="w"> </span><span class="n">curr_lane_left_width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">GetBufferBetweenADCCenterAndEdge</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">fmin</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">]),</span><span class="w"> </span><span class="n">adc_frenet_l_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">adc_frenet_l_</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">-</span><span class="n">curr_lane_right_width</span><span class="w"></span>
<span class="w">            </span><span class="o">?</span><span class="w"> </span><span class="o">-</span><span class="n">curr_lane_right_width</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">GetBufferBetweenADCCenterAndEdge</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">fmax</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="n">path_bound</span><span class="p">)[</span><span class="n">i</span><span class="p">]),</span><span class="w"> </span><span class="n">adc_frenet_l_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="regular">
<h3><a class="toc-backref" href="#id32">4.Regular</a><a class="headerlink" href="#regular" title="永久链接至标题">¶</a></h3>
<p><img alt="lane_change" src="../../../_images/regular.png" /></p>
<p>代码流程如下：</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">Status</span><span class="w"> </span><span class="nf">PathBoundsDecider::GenerateRegularPathBound</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ReferenceLineInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">LaneBorrowInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane_borrow_info</span><span class="p">,</span><span class="w"> </span><span class="n">PathBound</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">path_bound</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">blocking_obstacle_id</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">borrow_lane_type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1.初始化边界.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">InitPathBoundary</span><span class="p">(</span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"> </span><span class="n">path_bound</span><span class="p">))</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>


<span class="w">  </span><span class="c1">// 2.根据adc位置和lane信息确定大致的边界</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">GetBoundaryFromLanesAndADC</span><span class="p">(</span><span class="n">reference_line_info</span><span class="p">,</span><span class="w"> </span><span class="n">lane_borrow_info</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">path_bound</span><span class="p">,</span><span class="w"> </span><span class="n">borrow_lane_type</span><span class="p">))</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// PathBoundsDebugString(*path_bound);</span>

<span class="w">  </span><span class="c1">// 3.根据障碍物调整道路边界</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">GetBoundaryFromStaticObstacles</span><span class="p">(</span><span class="n">reference_line_info</span><span class="p">.</span><span class="n">path_decision</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                      </span><span class="n">path_bound</span><span class="p">,</span><span class="w"> </span><span class="n">blocking_obstacle_id</span><span class="p">))</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>流程和上面的几个基本类似，借道有三种类型</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">enum</span> <span class="k">class</span><span class="w"> </span><span class="nc">LaneBorrowInfo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">LEFT_BORROW</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">NO_BORROW</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">RIGHT_BORROW</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="path_decider_cn.html" title="路径决策"
             >下一页</a> |</li>
        <li class="right" >
          <a href="path_assessment_decider_cn.html" title="路径评估决策"
             >上一页</a> |</li>
        <li><a href="../../../index.html">Apollo home</a>&#160;|</li>
        <li><a href="../../../contents.html">Documentation</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">路径边界决策</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2021, xinetzone.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>